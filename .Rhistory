observe({
current_selection <- input$legislator
filtered_legislators <- unique(filtered_legdata()$name)
if (!is.null(input$legislator_enter_pressed)) {
data <- data %>% filter(grepl(input$legislator_enter_pressed, title, fixed = TRUE) | grepl(input$legislator_enter_pressed, description, fixed = TRUE))}
else{
# Update dropdown choices. This does not inherently cause recursion.
updateSelectizeInput(session, "legislator", choices = filtered_legislators,selected = current_selection)
}})
count_independent_votes <- reactive({
sum(filtered_data()$vote_with_neither == 1)
})
count_maverick_votes <- reactive({
sum(filtered_data()$maverick_votes == 1)
})
count_normal_votes <- reactive({
sum(filtered_data()$maverick_votes == 0 & filtered_data()$vote_with_neither == 0)
})
pct_independent_votes <- reactive({
round(count_independent_votes()/sum(!is.na(filtered_data()$vote_with_neither)),3)*100
})
pct_maverick_votes <- reactive({
round(count_maverick_votes()/sum(!is.na(filtered_data()$vote_with_neither)),3)*100
})
pct_normal_votes <- reactive({
round(count_normal_votes()/sum(!is.na(filtered_data()$vote_with_neither)),3)*100
})
observe({
current_selections <- input$voteType
choices_vector <- c("Independent", "Maverick", "Normal")
names(choices_vector) <- c(
paste0("Voted Against Both Parties (", count_independent_votes()," - ",pct_independent_votes(), "%)"),
paste0("Voted With Other Party (", count_maverick_votes()," - ",pct_maverick_votes(), "%)"),
paste0("Voted With Their Party (", count_normal_votes()," - ",pct_normal_votes(), "%)")
)
updateCheckboxGroupInput(session, "voteType",
#label = "Key Vote Type:",
choices = choices_vector,selected = current_selections)
})
output$legislatorProfile <- renderUI({
# Assuming 'heatmap_data' contains all the necessary legislator information
selected_legislator <- input$legislator
if (!is.null(selected_legislator) && selected_legislator != "") {
legislator_info <- heatmap_data %>%
filter(name == selected_legislator) %>% distinct(name, district, party, role, ballotpedia2) %>% slice(1)
div(
h3(a(href = legislator_info$ballotpedia2, target = "_blank", selected_legislator)),
p("District: ", legislator_info$district),
p("Party: ", legislator_info$party),
p("Chamber: ", legislator_info$role)
)
}
})
current_page <- reactiveVal(1)
items_per_page <- reactive({ as.numeric(input$items_per_page) })
paginated_data <- reactive({
if (nrow(filtered_data()) == 0) return(data.frame())
start_index <- (current_page() - 1) * items_per_page() + 1
end_index <- min(nrow(filtered_data()), start_index + items_per_page() - 1)
filtered_data()[start_index:end_index, ]
})
output$votesDisplay <- renderUI({
data <- paginated_data()
if (is.null(input$legislator) || input$legislator == "" || nrow(data) == 0) {
return(div(class = "no-data", "No bills available for display."))
}
# Dynamically create UI elements for each bill
ui_elements <- lapply(unique(data$number), function(bill) {
bill_data <- data[data$number == bill, ]
bill_title <- unique(bill_data$title)[1]
descriptions <- unique(bill_data$description)
html_string <- paste0("<h4>", bill_title, " - ", "<a href='", bill_data$url[1], "' target='_blank'>", bill_data$number[1],"</a></h4>","<h5>",bill_data$session_name[1],"</h5><p>",bill_data$description[1],"</p>")
div(class = 'bill-container',
html_content <- HTML(html_string),
actionButton(inputId = sprintf('vote-details-link-%s', gsub("[^A-Za-z0-9]", "", bill)),
label = "Vote Details Info",
class = "btn btn-info vote-details-button"),
div(
id = sprintf('vote-details-%s', gsub("[^A-Za-z0-9]", "", bill)),
class = 'vote-details',
style = 'display:none;',
lapply(unique(bill_data$roll_call_id), function(roll_call) {
roll_call_data <- bill_data[bill_data$roll_call_id == roll_call, ]
pct_yes <- paste0(round(roll_call_data$true_pct[1] * 100, 2), "%")
date_format <- format(as.Date(roll_call_data$date),"%b %d, %Y")
special_vote_class <- ifelse(roll_call_data$vote_with_neither[1] == 1, "independent-vote",
ifelse(roll_call_data$maverick_votes[1] == 1, "maverick-vote", "regular-vote"))
special_vote_text <- ifelse(roll_call_data$vote_with_neither[1] == 1,
"This legislator voted <b><i>against</i></b> the majorities of both parties.",
ifelse(roll_call_data$maverick_votes[1] == 1,
sprintf("This legislator voted <b><i>against</i></b> the majority of their party (%s) and <b><i>with</i></b> the majority of the other party.", roll_call_data$party[1]),
"This legislator voted with their party majority."))
legislator_vote <- paste(roll_call_data$name[1], "voted", roll_call_data$vote_text[1])
div(class = paste("votes",special_vote_class),
HTML(paste0(
"<p>",roll_call_data$desc," - <b>", date_format,"</b></p><p>", pct_yes, " of legislators voted Yea. </p><p>", special_vote_text, "</p><p>", legislator_vote,"</p><p class='disclaimer'><i>This vote wasn't necessarily a vote of the bill, and it could have been a vote on an amendment. For more details, examine the bill's <a href='",roll_call_data$state_link,"' target='_blank'>vote information</a> on the Legislature's website or examine the <a href='", bill_data$url[1], "' target='_blank'>bill page.</a></i></p>"))
)
}) #close lapply
) #close vote detail div
) #close bill container div
}) #close other lapply
do.call(tagList, ui_elements)
}) #close renderui
observe({
if("R" %in% values$party) {
runjs('$("#btn_party_R").addClass("selected");')
} else {
runjs('$("#btn_party_R").removeClass("selected");')
}
})
observe({
if("D" %in% values$party) {
runjs('$("#btn_party_D").addClass("selected");')
} else {
runjs('$("#btn_party_D").removeClass("selected");')
}
# Repeat for other buttons
})
observe({
if("Rep" %in% values$role) {
runjs('$("#btn_role_Rep").addClass("selected");')
} else {
runjs('$("#btn_role_Rep").removeClass("selected");')
}
# Repeat for other buttons
})
observe({
if("Sen" %in% values$role) {
runjs('$("#btn_role_Sen").addClass("selected");')
} else {
runjs('$("#btn_role_Sen").removeClass("selected");')
}
# Repeat for other buttons
})
observe({
if("N" %in% values$final) {
runjs('$("#btn_final_N").addClass("selected");')
} else {
runjs('$("#btn_final_N").removeClass("selected");')
}
# Repeat for other buttons
})
observe({
if("Y" %in% values$final) {
runjs('$("#btn_final_Y").addClass("selected");')
} else {
runjs('$("#btn_final_Y").removeClass("selected");')
}
})
observeEvent(input$prev_page, { if (current_page() > 1) current_page(current_page() - 1) })
observeEvent(input$next_page, {
total_items <- nrow(filtered_data())
if ((current_page() * items_per_page) < total_items) current_page(current_page() + 1)
})
observeEvent(input$first_page, {
current_page(1)
})
observeEvent(input$info, {
showModal(modalDialog(
title = "Vote Types",HTML("
<p>There are three main ways legislators vote:</p>
<p>1. They vote with the majority of their own party, even when it means voting with a majority of the opposing party on bipartisan or unanimous votes.</p>
<p>2. They vote against the majority of legislators in both parties.</p>
<p>3. Or they vote against the majority of the legislators in their own party AND with the majority of the opposing party.</p>
")
))
})
observeEvent(input$last_page, {
total_pages <- ceiling(nrow(filtered_data()) / items_per_page)
current_page(total_pages)
shinyjs::toggleState("first_page", condition = current_page() > 1)
shinyjs::toggleState("prev_page", condition = current_page() > 1)
shinyjs::toggleState("next_page", condition = current_page() < total_pages)
shinyjs::toggleState("last_page", condition = current_page() < total_pages)
})
output$page_info <- renderUI({
total_items <- nrow(filtered_data())
start_item <- (current_page() - 1) * items_per_page() + 1
end_item <- min(start_item + items_per_page() - 1, total_items)
# Using HTML() to include a line break (<br>) or any other HTML tags
formatted_start_item <- format(start_item, big.mark = ",")
formatted_end_item <- format(end_item, big.mark = ",")
formatted_total_items <- format(total_items, big.mark = ",")
HTML(paste0("Showing items ", formatted_start_item, " to<br>", formatted_end_item, " of ", formatted_total_items))
})
output$filterFeedback <- renderText({
filtered_count <- nrow(filtered_data())
formatted_count <- format(filtered_count, big.mark = ",")
paste("Showing", formatted_count, "results based on current filters.")
})
shinyjs::runjs('
$(document).on("click", ".vote-details-button", function() {
var detailsId = $(this).attr("id").replace("vote-details-link-", "vote-details-");
$("#" + detailsId).toggle();
});
')})
}
app_vote_patterns <- dbGetQuery(con, "SELECT * FROM app_shiny.app_vote_patterns")
########################################
#                                      #
# define Postgres connection function  #
#                                      #
########################################
attempt_connection <- function() {
# Prompt for password
password_db <- readline(
prompt="Make sure ye've fired up the Postgres server and hooked up to the database.
Now, what be the secret code to yer treasure chest o' data?: ")
# Attempt to connect to Postgres database
con <- tryCatch(
dbConnect(RPostgres::Postgres(),
dbname = "fl_leg_votes",
host = "localhost",
port = 5432,
user = "postgres",
password = password_db),
error = function(e) {
message("Connection failed: ", e$message)
return(NULL)
}
)
return(con)
}
shiny::runApp()
file.copy("server_postgres.R","archive/bkp 2024_06_28 server_postgres.R")
View(app_vote_patterns)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
View(app_vote_patterns)
runApp()
data$roll_call_id <- reorder(data$roll_call_id, data$bill_number)
runApp()
runApp()
rm(app_vote_patterns)
rm(app_vote_patterns_filtered())
rm(app_vote_patterns_filtered
)
rm(priority_votes)
rm(r_partisan_votes)
rm(d_partisan_votes)
rm(r_votes)
rm(d_votes)
runApp()
# Loop until successful connection
repeat {
con <- attempt_connection()
if (!is.null(con) && dbIsValid(con)) {
print("Successfully connected to the database!")
break
} else {
message("Failed to connect to the database. Please try again.")
}
}
# pull in Postgres data
app_vote_patterns <- dbGetQuery(con, "SELECT * FROM app_shiny.app_vote_patterns")
library(foreach)
library(profvis)
library(data.table)
library(jsonlite)
library(lubridate)
library(forcats)
library(stringr)
library(dplyr)
library(purrr)
library(readr)
library(tidyr)
library(tibble)
library(ggplot2)
library(tidyverse)
library(DBI) # added 6/13/24 for Postgres connectivity
library(RPostgres) # added 6/13/24 for Postgres connectivity
print("look for password prompt, which is currently needed to start the app")
rm(list=ls())
########################################
#                                      #
# define functions                     #
#                                      #
########################################
attempt_connection <- function() {
# Prompt for password
password_db <- readline(
prompt="Make sure ye've fired up the Postgres server and hooked up to the database.
Now, what be the secret code to yer treasure chest o' data?: ")
# Attempt to connect to Postgres database
con <- tryCatch(
dbConnect(RPostgres::Postgres(),
dbname = "fl_leg_votes",
host = "localhost",
port = 5432,
user = "postgres",
password = password_db),
error = function(e) {
message("Connection failed: ", e$message)
return(NULL)
}
)
return(con)
}
# Loop until successful connection
repeat {
con <- attempt_connection()
if (!is.null(con) && dbIsValid(con)) {
print("Successfully connected to the database!")
break
} else {
message("Failed to connect to the database. Please try again.")
}
}
# pull in Postgres data
app_vote_patterns <- dbGetQuery(con, "SELECT * FROM app_shiny.app_vote_patterns")
# disconnect the database because the data has already been loaded into memory
dbDisconnect(con)
print("Disconnected from the database.")
app_data <- dbGetQuery(con, "SELECT * FROM app_shiny.app_data")
# Loop until successful connection
repeat {
con <- attempt_connection()
if (!is.null(con) && dbIsValid(con)) {
print("Successfully connected to the database!")
break
} else {
message("Failed to connect to the database. Please try again.")
}
}
# pull in Postgres data
app_vote_patterns <- dbGetQuery(con, "SELECT * FROM app_shiny.app_vote_patterns")
app_data <- dbGetQuery(con, "SELECT * FROM app_shiny.app_data")
jct_bill_categories <- dbGetQuery(con, "SELECT * FROM proc.jct_bill_categories")
# disconnect the database because the data has already been loaded into memory
dbDisconnect(con)
print("Disconnected from the database.")
############################################
#                                          #
# read additional data stored in R project #
#                                          #
############################################
# read data stored in this project; stopgap until I get all postgres data 100% in order
load("data.RData")
print(y_labels)
str(y_labels)
head(y_labels)
cat(y_labels[1])
shiny::runApp()
runApp()
runApp()
View(app_vote_patterns)
runApp()
runApp()
runApp()
runApp()
rm(y_labels)
runApp()
runApp()
View(app_vote_patterns)
View(app_vote_patterns)
runApp()
View(app_vote_patterns)
runApp()
runApp()
rm(list=ls())
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(app_vote_patterns)
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
source("read_data.R")
runApp()
library(foreach)
library(profvis)
library(data.table)
library(jsonlite)
library(lubridate)
library(forcats)
library(stringr)
library(dplyr)
library(purrr)
library(readr)
library(tidyr)
library(tibble)
library(ggplot2)
library(tidyverse)
library(DBI) # added 6/13/24 for Postgres connectivity
library(RPostgres) # added 6/13/24 for Postgres connectivity
runApp()
labels <- unique(data[, c("legislator_name", "district_number")])
#     data_sorted <- data_filtered %>% arrange(mean_partisan_metric)
#   } else if (input$sort_by == "District") {
#     data_sorted <- data_filtered %>% arrange(party)
#   }
# })
#####################
#                   #
# app 1 plot        #
#                   #
#####################
output$heatmapPlot <- renderPlotly({
data <- data_filtered()
# Determine colors based on party
#create hover text
data$hover_text <- mapply(
createHoverText,
numbers = data$bill_number,
descs = data$roll_call_desc,
title = data$bill_title,
date = data$roll_call_date,
descriptions = data$bill_desc,
urls = data$bill_url,
pcts = data$pct_voted_for,
vote_texts = data$vote_text,
names = data$legislator_name,
SIMPLIFY = FALSE  # Keep it as a list
)
data$hover_text <- sapply(data$hover_text, paste, collapse = " ") # Collapse the list into a single string
# data$hover_text = "DEBUG"
numBills <- n_distinct(data$roll_call_id) # Adjust with your actual identifier
# Dynamic height calculation
baseHeight <- 500 # Minimum height
perBillHeight <- 10 # Height per bill
totalHeight <- baseHeight + (numBills * perBillHeight) # Total dynamic height
low_color <- if(input$party == "D") "#4575b4" else if(input$party == "R") "#d73027" else "#4575b4"
mid_color <- "#6DA832"
high_color <- if(input$party == "D") "#d73027" else if(input$party == "R") "#4575b4" else "#d73027"
# configure y-axis sort order
#data$legislator_name <- reorder(data$legislator_name, data$mean_partisan_metric)
if (input$sort_by == "Name") {
data$legislator_name <- reorder(data$legislator_name, data$legislator_name)
} else if (input$sort_by == "Partisanship") {
data$legislator_name <- reorder(data$legislator_name, data$mean_partisan_metric)
} else if (input$sort_by == "District") {
data$legislator_name <- reorder(data$legislator_name, data$district_number)
}
data$bill_number <- as.character(data$bill_number)
data <- data[order(data$bill_number), ]
data$roll_call_id <- factor(data$roll_call_id, levels = unique(data$roll_call_id))
labels <- unique(data[, c("legislator_name", "district_number")])
x_labels <- setNames(paste(labels$legislator_name, "(", labels$district_number, ")", sep = ""), labels$legislator_name)
# Generate the plot
p <- ggplot(data, aes(x = legislator_name, y = roll_call_id, fill = partisan_metric, text = hover_text)) +
geom_tile(color = "white", linewidth = 0.1) +
scale_fill_gradient2(low = low_color, high = high_color, mid = "#6DA832", midpoint = 1,
) +
theme_minimal() +
scale_y_discrete(labels = function(x) {
labels <- unique(data[, c("roll_call_id", "bill_number", "session_year")])
setNames(paste(labels$bill_number, labels$session_year, sep = " - "), labels$roll_call_id)
}) +
scale_x_discrete(position = "top") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 10),
axis.ticks.y = element_blank(),
axis.title.y = element_blank(),
axis.title.x = element_blank(),
axis.text.y = element_text(size = 10),
legend.position = "none",
plot.title = element_blank(),
plot.subtitle = element_blank())
ggplotly(p, tooltip = "text") %>%
layout(autosize=TRUE,xaxis=list(side="top"),
font = list(family = "Archivo"),
margin = list(t=85), #list(l = 0, r = 0, t = 60, b = 10),  # Adjust margins to ensure the full title and subtitle are visible,
plot_bgcolor = "rgba(255,255,255,0.85)",  # Transparent plot background
paper_bgcolor = "rgba(255,255,255,0.85)",
height = totalHeight
) %>%
config(displayModeBar = FALSE)
})
runApp()
runApp()
runApp()
